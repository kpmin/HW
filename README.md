# HW1

| 1-1 | 변수 선언 시 메모리 공간이 식별자 이름으로 확보됨을 확인 | 
| 1-2 | 변수는 데이터 영역 주소를 저장하고 데이터는 해당 위치에 존재 |
| 1-3 | 수, 문자열 등 원시 값은 불변 값임을 확인 |
| 1-4 | 참조형 데이터는 변수에 따라 값이 변할 수 있음 |
| 1-5 | 프로퍼티 재할당 시 객체 주소가 바뀜을 확인 |
| 1-6 | 객체 내부에 객체가 있을 때 중첩 참조 발생 |
| 1-7 | 두 변수가 같은 객체를 참조할 수 있음 |
| 1-8 | 복사한 객체의 프로퍼티 수정이 원본에도 영향 |
| 1-9 | 완전히 새 객체로 복사하면 독립된 객체가 됨 |
| 1-10 | 얕은 복사 시 원본 객체의 속성이 함께 변경될 수 있음 |
| 1-11 | 객체를 새로 생성하여 불변성 유지 |
| 1-12 | 객체 얕은 복사 함수 구현 |
| 1-13 | 사용자 정의 복사 함수로 불변성 유지 |
| 1-14 | 얕은 복사는 중첩 객체까지 복사하지 않음 |
| 1-15 | 깊은 복사로 내부 속성까지 복사함 |
| 1-16 | 재귀적 깊은 복사 함수 구현 |
| 1-17 | 깊은 복사 후 원본과 독립된 객체 생성됨 |
| 1-18 | JSON 활용 깊은 복사 시 함수는 제외됨 |
| 1-19 | undefined가 자동 부여되는 3가지 경우 확인 |
| 1-20 | 배열의 undefined 요소와 빈 요소는 다름 |
| 1-21 | 빈 요소는 배열 순회 메서드에서 제외됨 |
| 1-22 | typeof null은 object를 반환하므로 일치 연산자 필요 |

| 2-1 | 함수 호출 시 콜 스택에 컨텍스트 쌓이는 순서를 확인 |
| 2-2 | 호이스팅에 의해 예상치 못한 출력 발생 |
| 2-3 | 매개변수도 변수 선언처럼 호이스팅됨 |
| 2-4 | 호이스팅 상태 코드에서도 결과가 동일함을 확인 |
| 2-5 | 원본 코드를 통해 호이스팅 개념 예측 및 검증 |
| 2-6 | 변환된 코드로 동일 결과 확인하여 개념 심화 |
| 2-7 | 함수 선언문과 표현식 차이 확인 |
| 2-8 | 익명/기명 함수 표현식의 범위 차이 확인 |
| 2-9 | 함수 선언문은 정상, 표현식은 에러 발생 비교 |
| 2-10 | 호이스팅 변환 코드에서 동일한 결과 확인 |
| 2-11 | 같은 이름 함수 선언 시 마지막 것이 우선됨 |
| 2-12 | 함수 표현식은 중복 선언 시 에러 발생함 |
| 2-13 | inner 컨텍스트의 식별자 우선 접근 확인 |
| 2-14 | 스코프 체인 확인 (브라우저 콘솔) |
| 2-15 | 내부 함수에서도 외부 변수 접근 가능 |
| 2-16 | debugger 사용해 실행 중 스코프 확인 가능 |

| 3-1 | 브라우저에서 this는 window와 동일 |
| 3-2 | Node.js에서는 global이 this |
| 3-3 | 전역 변수는 window/this에서 접근 가능 |
| 3-4 | 전역 객체의 프로퍼티 수정 가능 여부 확인 |
| 3-5 | var 선언 변수는 delete 불가능 |
| 3-6 | 일반 호출 vs 메소드 호출의 this 비교 |
| 3-7 | 대괄호 표기법으로 호출 시 this 참조 확인 |
| 3-8 | 현재 객체를 this로 참조하는 예시 |
| 3-9 | 내부 함수는 기본적으로 전역 객체 참조 |
| 3-10 | self를 이용해 외부 this 참조 유지 |
| 3-11 | 화살표 함수는 외부 this를 그대로 참조 |
| 3-12 | setTimeout 등 비동기 호출 시 this 변화 확인 |
| 3-13 | 생성자 함수로 객체 생성 시 this 확인 |
| 3-14 | call 메서드로 this를 지정하여 호출 |
| 3-15 | 다른 객체로 this 바인딩 후 호출 확인 |
| 3-16 | apply 메서드를 통한 인자 배열 전달 확인 |
| 3-17 | 객체에 배열 메서드 적용 예제 |
| 3-18 | arguments 객체 및 DOM 컬렉션 배열화 |
| 3-19 | 문자열 조작에 배열 메서드 적용 결과 확인 |
| 3-20 | Array.from으로 객체를 배열로 변환 |
| 3-21 | 생성자에서 call/apply로 상속 구현 확인 |
| 3-22 | 배열에서 최댓값/최솟값 찾기 |
| 3-23 | Math 객체 활용 최댓값/최솟값 찾기 |
| 3-24 | 전개 연산자와 Math 객체 함께 사용 |
| 3-25 | bind로 this와 인자 고정된 함수 생성 |
| 3-26 | bind된 함수도 원래 함수명 유지 |
| 3-27 | call/bind를 통한 this 유지 전략 |
| 3-28 | setTimeout에서 this 바인딩 비교 |
| 3-29 | 화살표 함수의 this는 상위 스코프 유지 |
| 3-30 | 메서드에서 this를 활용한 평균 계산 |
| 3-31 | 배열과 Set 메서드의 콜백 및 this 전달 확인 |